## 学习笔记

#### 微服务概览

###### 单体架构的不足

很明显单体架构当项目规模庞大后存在很多问题,比如如下问题:

- 人员的职责问题,那么多人围绕一个项目进行开发,难免不会出现问题。
- 上线部署的周期将变长，整个包的编译周期也变长。
- 那么大一个包，如果一个地方出问题，整个进程就可能出现问题。

所以需要进行分治的方法进行拆分，而微服务就是其中一种服务组织方式。

###### 微服务哪里来

最开始的时候，微服务这种形式就叫SOA,其实差不多一个意思，就是远程调用的一种，用官方一点的话说就是“微服务就是SOA的一种实现”

也就是说微服务这种形式很早就出现了，不是说Golang出现了微服务才出现，更早一点搞C/C++那帮人早就在玩微服务了。最早的想法就是网络服务也类似Unix-like 管道的模式出现，一个的输出给另外一个的输入，这就是微服务的[最原始想法][microservices history]。

所以要写好微服务就和写好其他软件一样，要遵循以下几个特性：

- 小即是美
- 单一职责
- 尽可能早的创建原型
- 可移植性比效率更重要

###### 怎样才算微服务

上面的想法当然只是指导思想，也不能当饭吃，我们需要一个可以落地实践的方法。具体来说可以满足如下特性：

原子服务：服务的粒度一定要尽量小，小到只关注一个业务领域，比如商城系统中，订单服务就是一个原子服务。

独立进程：只有做到进程级别的隔离，这样才能不会在服务之间互相受影响

![alt text](https://martinfowler.com/articles/microservices/images/micro-deployment.png "microservices in multiprocess")

隔离部署：利用现在的虚拟化技术，可以单独部署服务，做到互相不受影响。

去中心化服务治理:不需要把多个职责都集中在中心服务去处理，而是分散在整个集群中。

###### 微服务改造后带来的问题

- 网络服务间消息传递代价过高

1）本来库与库之间的本地方法调用，不需要过多的网络消耗，速度自然比需要网络消耗的微服务更加快。

解决方案：减少网络消耗，能通过批量接口去请求的，不采用单一接口去请求，以免产生请求放大问题。

当然微服务改造后本身也会带来问题，这也是很多企业不改造的原因，一方面本身业务太杂乱，另外一方面就是微服务也算是新兴的一个领域。但是，相信以后随着基础云的改进和方法论的提高，这种方式会被更多大中型企业接受。

2）串行化服务调用会造成雪崩效应，比如A调用B,B调用C,C调用D,一旦D挂掉，会造成上面一系列的调用都返回失败，更重要的是这些调用都是串行的，必须等C调用返回后，B才能返回信息给A。

解决方案：Golang里面处理这个问题比较容易，就是用并行化的方式去请求，不需要在那里死等。

- 微服务的数据库往往是隔离的，都各自采用自己的业务库，但是这样会带来跨DB事物问题
- 现在微服务由于是分布式的，所以测试自然比较麻烦
- 另外服务之间由于依赖，升级的时候，会同时影响到几个服务
- 巨石架构时代，单体应用部署和运维都比较集中，而微服务架构下，服务都比较分散，自然对基础设施提出了更高的要求，比如Paas系统

###### 组件服务化的组成

组件一旦拆分成组件化服务后，如果只是单一组件的挂掉，因为一般都有冗余的同组件，所以相对来说影响比较小。在看部署的时候，我们也只需部署对应的修改组件部分就完了，而如果是单体架构，则需要整个应用进行重新打包和部署。

下面简单说说在Golang里微服务是有哪些部分组成：

Kit:微服务基础库，比如go-kit,go-micro,go-zero等等，这些往往都是由有经验的程序员写的，而且有很多线上使用案例，我们只需要拿来用就可以。

Service:业务代码+Kit依赖+第三方依赖

RPC:服务与服务之间同步调用

MQ:服务与服务之间异步调用

###### 按业务组织服务

组织架构一定程度上反应了业务架构，比如公司从大部门来说一般由前端团队，业务部门，基础支撑部门，运维部门等，然后反应在架构模式上就是

大前端（移动、WEB）=>业务服务=>平台服务=>基础设施(PaaS平台),这个是一个很自然的划分方式。

###### 去中心化

数据去中心化：

每个微服务都独占DB，互相之间存储隔离，通过RPC来互相通信

治理去中心化：

尽量不产生中心节点，过度依赖中心节点，则会对中心节点造成大量压力，而不容易进行扩展

技术去中心化：

微服务本质上可以采用任何语言进行接入，但是也需要在架构师能够掌控的范围内，即做到技术的收敛性

###### 基础设施自动化

CI/CD:Gitlab+Gitlab Hook+K8S

Testing:单元测试一定要做，API测试自动化，测试环境要分开

在线运行时：K8S,以及一系列监控工具

###### 可用性和兼容性

对错误进行防御方式编程，进行逻辑处理之前，都进行错误判断

可以采用以下几种方式进行错误的处理：

服务隔离，超时控制，负载保护，限流，降级，重试，负载均衡



在兼容性上面，上下游通信都采用契约式通信，下游谨慎修改已经发布的契约。尽量做到发送时要保守，接收时要开放的原则。

#### 微服务设计 & 架构演化历史

###### 微服务版本V1.0

架构师小毛根据业务发展的需要，把单体架构拆分成微服务，如下图

![微服务版本V1.0](https://chenxf.org/usr/uploads/2020/12/2748878723.png)


可以看到，这种模式存在如下几个问题：

1. 客户端和服务端之间是直接通信的，也就是他们之间是强耦合
2. 服务是根据业务的边界进行拆分的，所以服务端在一个页面上可能需要完成多个请求才能保证具体的呈现
3. 多个服务协议是多种多样的，客户端每次都需要去做适配
4. 面向“端”的API适配，耦合到了内部服务
5. 多个终端兼容逻辑复杂，这些都需要服务自己做处理
6. 统一的逻辑都各自维护一套，杂乱且重复

###### 微服务版本V2.0

于是架构师小毛又对V1.0的架构继续演进，为了解决问题1，问题2，问题3，问题4,问题5则引入了app-interface,作为服务端统一的出口，在服务内部实现了dataset join,按照业务case设计粗粒度的API,给后续的演进带来很多优势。

- 轻量级交互：这时客户端只需要统一和app-interface进行交互就可以了
- 差异服务：数据裁剪和聚合，根据具体终端进行定制就可以了
- 动态升级：服务的内聚性，对外是屏蔽了内部服务的细节的，所以可以随时升级
- 沟通提升：客户端同事直接可以去找网关小组进行沟通，而不用去找具体的多个微服务小组进行沟通

这里的app-interface通常被称为BFF,BFF一般被认为是一种适配服务，将其后面的服务进行聚合或者裁剪，然后向无线端暴露统一的接口API,所以这时小毛绘制的架构图是这样的。但是聪明的小毛同学马上发现了版本V2.0存在的问题，比如app-interface其实很容易引发单点故障。

![](https://chenxf.org/usr/uploads/2020/12/381906793.png)


###### 微服务版本V3.0

既然单点存在故障，我们就多部署几个app-interface,于是小毛又重新绘制了架构图如下：

![](https://chenxf.org/usr/uploads/2020/12/2118527434.png)

V3.0架构在线上运行了一段时间，但是渐渐出现了一些问题，比如安全认证，日志监控，限流熔断等都需要各个服务自己去做，而这些做法其实是有很大冗余的。

###### 微服务版本V4.0

这时，架构师小毛思索了一段时间，发现既然大量的app-interface都存在重复的逻辑，那在其上再加入一层，引入Gateway网关层来做统一处理。网关一般是由性能比较出众的开源组件搭建，根据自己的业务特性进行改造。小毛又对V4.0画了如下图进行描述：

![](https://chenxf.org/usr/uploads/2020/12/3409512239.png)


至此，客户端流量会经过网关，然后到BFF,然后再进入微服务进行处理，BFF可以用任何服务端技术实现，比如nodejs等。

参考材料:

[microservices history]: https://en.wikipedia.org/wiki/Microservices

[unix programming art](https://www.amazon.com/UNIX-Programming-Art-Eric-S-Raymond/dp/B008Z1IEQ8)

[microservices](https://martinfowler.com/articles/microservices.html)